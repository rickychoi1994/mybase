# 变量、作用域和内存问题


## 基本类型和引用类型的值

EMCAscript变量可能包含两种不同数据类型的值: **基本类型值** 和 **引用类型值**。

引用类型值是保存在内存中的对象。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。

:::warning 注意
这种说法不严密，当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。
:::


## 传递参数

**ECMAscript中所有函数的参数都是按值传递的。** 也就是说，把函数外部的值复制给函数内部的参数。

```javascript
function setName (obj) {
  obj.name = 'jane'
}
var person = new Object()
setName(person)
person.name // jane

// 在函数内部，obj和person引用的同一个对象。
// 换句话说，即使这个变量是按值传递的，obj也会按引用来访问同一个对象。于是，当在函数内部为obj添加name属性后，函数外部的person也将有反映。
// 因为person指向的对象在堆内存中只有一个，而且是全局对象。


function setName (obj) {
  obj.name = 'jane'
  obj = new Object()
  obj.name = 'John'
}
var person = new Object()
setName(person)
person.name // jane

// 添加了两行代码，一行代码为obj重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。
// 在把person传递给setName()后，其name属性被设置为jane。然后，又将一个新对象赋给变量obj，同时将其name属性设置为John。
// 如果person是按引用传递的，那么person将会自动被修改为指向其name属性值为John的新对象。
// 这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。
// 实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。
```


## 执行环境及作用域

执行环境是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的**变量对象**，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。

全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是`window对象`，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着。

当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。

### 没有块级作用域

使用`var`声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境。


## 垃圾收集

JavaScript具有自动垃圾收集的机制。

原理：找出那些不再继续使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔(或代码执行中预定的手机时间)，周期性地执行这一操作。

### 标记清除

JavaScript中最常用的垃圾收集方式是**标记清除**。

垃圾收集器在运行时的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后在被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

### 引用计数

另一种不常见的垃圾收集策略叫做引用计数。

引用计数的含义是跟踪记录每一个值被引用的次数。


## 性能问题

### 管理内存

确保占用最少的内存可以让页面获得更好的性能。优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为`null`来释放其引用，这个方法叫做**解除引用**。

解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。
